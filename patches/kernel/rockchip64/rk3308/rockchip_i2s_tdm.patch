From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: John Doe <john.doe@somewhere.on.planet>
Date: Sat, 18 Oct 2025 17:23:32 +0600
Subject: Patching kernel rockchip64 files
 sound/soc/rockchip/rockchip_i2s_tdm.c

Signed-off-by: John Doe <john.doe@somewhere.on.planet>
---
 sound/soc/rockchip/rockchip_i2s_tdm.c | 309 +++++++++-
 1 file changed, 283 insertions(+), 26 deletions(-)

diff --git a/sound/soc/rockchip/rockchip_i2s_tdm.c b/sound/soc/rockchip/rockchip_i2s_tdm.c
index 3b46c59edbdd..7744bee896ea 100644
--- a/sound/soc/rockchip/rockchip_i2s_tdm.c
+++ b/sound/soc/rockchip/rockchip_i2s_tdm.c
@@ -9,10 +9,12 @@
 #include <linux/clk-provider.h>
 #include <linux/delay.h>
 #include <linux/mfd/syscon.h>
 #include <linux/module.h>
 #include <linux/of.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
 #include <linux/pm_runtime.h>
 #include <linux/regmap.h>
 #include <linux/reset.h>
 #include <linux/spinlock.h>
 #include <sound/dmaengine_pcm.h>
@@ -20,11 +22,10 @@
 
 #include "rockchip_i2s_tdm.h"
 
 #define DRV_NAME "rockchip-i2s-tdm"
 
-#define DEFAULT_MCLK_FS				256
 #define CH_GRP_MAX				4  /* The max channel 8 / 2 */
 #define MULTIPLEX_CH_MAX			10
 
 #define TRCM_TXRX 0
 #define TRCM_TX 1
@@ -57,16 +58,29 @@ struct rk_i2s_tdm_dev {
 	struct snd_dmaengine_dai_dma_data playback_dma_data;
 	struct reset_control *tx_reset;
 	struct reset_control *rx_reset;
 	const struct rk_i2s_soc_data *soc_data;
 	bool is_master_mode;
+//+++
+	bool mclk_external;					// using external master-clock source connected to pin I2SX_8CH_MCLK 
+	bool mclk_ext_mux;					// external master-clock source has to two switchable generators x44 and x48
+	bool s2mono;						// using two separate I2S out for left/right channels (dual mono mode)
+	struct clk *mclk_ext;				// external master-clock source
+	struct clk *clk_44;					// external x44 generator
+	struct clk *clk_48;					// external x48 generator
+    struct gpio_desc *dsd_gpio;			// DSD output indicator
+    bool inverse_dsd;					// direct or inverse signal of DSD
+	//int dcount;
+//+++
 	bool io_multiplex;
 	bool tdm_mode;
 	unsigned int frame_width;
 	unsigned int clk_trcm;
 	unsigned int i2s_sdis[CH_GRP_MAX];
 	unsigned int i2s_sdos[CH_GRP_MAX];
+	// don't turn off word clock output
+	bool leave_word_clock;
 	int refcount;
 	spinlock_t lock; /* xfer lock */
 	bool has_playback;
 	bool has_capture;
 	struct snd_soc_dai_driver *dai;
@@ -88,10 +102,11 @@ static int to_ch_num(unsigned int val)
 	}
 }
 
 static void i2s_tdm_disable_unprepare_mclk(struct rk_i2s_tdm_dev *i2s_tdm)
 {
+	dev_info(i2s_tdm->dev, "i2s_tdm_disable_unprepare_mclk\n");
 	clk_disable_unprepare(i2s_tdm->mclk_tx);
 	clk_disable_unprepare(i2s_tdm->mclk_rx);
 }
 
 /**
@@ -105,10 +120,11 @@ static void i2s_tdm_disable_unprepare_mclk(struct rk_i2s_tdm_dev *i2s_tdm)
  * Returns success (0) or negative errno.
  */
 static int i2s_tdm_prepare_enable_mclk(struct rk_i2s_tdm_dev *i2s_tdm)
 {
 	int ret = 0;
+	dev_info(i2s_tdm->dev, "i2s_tdm_prepare_enable_mclk\n");
 
 	ret = clk_prepare_enable(i2s_tdm->mclk_tx);
 	if (ret)
 		goto err_mclk_tx;
 	ret = clk_prepare_enable(i2s_tdm->mclk_rx);
@@ -121,26 +137,28 @@ static int i2s_tdm_prepare_enable_mclk(struct rk_i2s_tdm_dev *i2s_tdm)
 	clk_disable_unprepare(i2s_tdm->mclk_tx);
 err_mclk_tx:
 	return ret;
 }
 
-static int i2s_tdm_runtime_suspend(struct device *dev)
+static int __maybe_unused i2s_tdm_runtime_suspend(struct device *dev)
 {
 	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+	dev_info(i2s_tdm->dev, "i2s_tdm_runtime_suspend\n");
 
 	regcache_cache_only(i2s_tdm->regmap, true);
 	i2s_tdm_disable_unprepare_mclk(i2s_tdm);
 
 	clk_disable_unprepare(i2s_tdm->hclk);
 
 	return 0;
 }
 
-static int i2s_tdm_runtime_resume(struct device *dev)
+static int __maybe_unused i2s_tdm_runtime_resume(struct device *dev)
 {
 	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
 	int ret;
+	dev_info(i2s_tdm->dev, "i2s_tdm_runtime_resume\n");
 
 	ret = clk_prepare_enable(i2s_tdm->hclk);
 	if (ret)
 		goto err_hclk;
 
@@ -191,10 +209,11 @@ static void rockchip_snd_xfer_sync_reset(struct rk_i2s_tdm_dev *i2s_tdm)
 	 * fine for playback. During duplex (playback + capture) operation,
 	 * this might become an issue, but that should be solved by the
 	 * implementation of the aforementioned API, not by shoving a reset
 	 * controller into an audio driver.
 	 */
+	dev_info(i2s_tdm->dev, "rockchip_snd_xfer_sync_reset\n");
 
 	reset_control_assert(i2s_tdm->tx_reset);
 	reset_control_assert(i2s_tdm->rx_reset);
 	udelay(10);
 	reset_control_deassert(i2s_tdm->tx_reset);
@@ -217,24 +236,27 @@ static void rockchip_snd_xfer_clear(struct rk_i2s_tdm_dev *i2s_tdm,
 	unsigned int xfer_val = 0;
 	unsigned int val;
 	int retry = 10;
 	bool tx = clr & I2S_CLR_TXC;
 	bool rx = clr & I2S_CLR_RXC;
+	dev_info(i2s_tdm->dev, "rockchip_snd_xfer_clear\n");
 
 	if (!(rx || tx))
 		return;
 
 	if (tx) {
 		xfer_mask = I2S_XFER_TXS_START;
 		xfer_val = I2S_XFER_TXS_STOP;
 	}
+	
 	if (rx) {
 		xfer_mask |= I2S_XFER_RXS_START;
 		xfer_val |= I2S_XFER_RXS_STOP;
 	}
 
 	regmap_update_bits(i2s_tdm->regmap, I2S_XFER, xfer_mask, xfer_val);
+	
 	udelay(150);
 	regmap_update_bits(i2s_tdm->regmap, I2S_CLR, clr, clr);
 
 	regmap_read(i2s_tdm->regmap, I2S_CLR, &val);
 	/* Wait on the clear operation to finish */
@@ -245,17 +267,26 @@ static void rockchip_snd_xfer_clear(struct rk_i2s_tdm_dev *i2s_tdm,
 		if (!retry) {
 			dev_warn(i2s_tdm->dev, "clear failed, reset %s%s\n",
 				 tx ? "tx" : "", rx ? "rx" : "");
 			if (rx && tx)
 				rockchip_snd_xfer_sync_reset(i2s_tdm);
-			else if (tx)
+			else if (tx) {
+//+++
+//				dev_dbg(i2s_tdm->dev, "%s tx_reset dcount = %u\n", 
+//					__func__, i2s_tdm->dcount++);
+//+++
 				rockchip_snd_reset(i2s_tdm->tx_reset);
+			}
 			else if (rx)
 				rockchip_snd_reset(i2s_tdm->rx_reset);
 			break;
 		}
 	}
+	if(tx && i2s_tdm->leave_word_clock)
+		regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+				   I2S_XFER_TXS_START,
+				   I2S_XFER_TXS_START);
 }
 
 static inline void rockchip_enable_tde(struct regmap *regmap)
 {
 	regmap_update_bits(regmap, I2S_DMACR, I2S_DMACR_TDE_ENABLE,
@@ -284,10 +315,11 @@ static inline void rockchip_disable_rde(struct regmap *regmap)
 static void rockchip_snd_txrxctrl(struct snd_pcm_substream *substream,
 				  struct snd_soc_dai *dai, int on)
 {
 	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
 	unsigned long flags;
+	dev_info(i2s_tdm->dev, "rockchip_snd_txrxctrl, i2s_tdm->refcount=%d\n", i2s_tdm->refcount);
 
 	spin_lock_irqsave(&i2s_tdm->lock, flags);
 	if (on) {
 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
 			rockchip_enable_tde(i2s_tdm->regmap);
@@ -316,25 +348,34 @@ static void rockchip_snd_txrxctrl(struct snd_pcm_substream *substream,
 	spin_unlock_irqrestore(&i2s_tdm->lock, flags);
 }
 
 static void rockchip_snd_txctrl(struct rk_i2s_tdm_dev *i2s_tdm, int on)
 {
+	dev_info(i2s_tdm->dev, "rockchip_snd_txctrl, on=%d\n", on);
+	
+//+++
+//	dev_dbg(i2s_tdm->dev, "%s on=%u dcount = %u\n", 
+//		__func__, on, i2s_tdm->dcount++);
+//+++
 	if (on) {
 		rockchip_enable_tde(i2s_tdm->regmap);
 
-		regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
-				   I2S_XFER_TXS_START,
-				   I2S_XFER_TXS_START);
+		if(!i2s_tdm->leave_word_clock)
+			regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+					   I2S_XFER_TXS_START,
+					   I2S_XFER_TXS_START);
 	} else {
 		rockchip_disable_tde(i2s_tdm->regmap);
 
-		rockchip_snd_xfer_clear(i2s_tdm, I2S_CLR_TXC);
+		if(!i2s_tdm->leave_word_clock)
+			rockchip_snd_xfer_clear(i2s_tdm, I2S_CLR_TXC);
 	}
 }
 
 static void rockchip_snd_rxctrl(struct rk_i2s_tdm_dev *i2s_tdm, int on)
 {
+	dev_info(i2s_tdm->dev, "rockchip_snd_rxctrl, on=%d\n", on);
 	if (on) {
 		rockchip_enable_rde(i2s_tdm->regmap);
 
 		regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
 				   I2S_XFER_RXS_START,
@@ -351,10 +392,16 @@ static int rockchip_i2s_tdm_set_fmt(struct snd_soc_dai *cpu_dai,
 {
 	struct rk_i2s_tdm_dev *i2s_tdm = to_info(cpu_dai);
 	unsigned int mask, val, tdm_val, txcr_val, rxcr_val;
 	int ret;
 	bool is_tdm = i2s_tdm->tdm_mode;
+	dev_info(i2s_tdm->dev, "rockchip_i2s_tdm_set_fmt, fmt=%u\n", fmt);
+
+//+++
+//	dev_dbg(i2s_tdm->dev, "%s dcount = %u\n", 
+//		__func__, i2s_tdm->dcount++);
+//+++
 
 	ret = pm_runtime_resume_and_get(cpu_dai->dev);
 	if (ret < 0 && ret != -EACCES)
 		return ret;
 
@@ -450,15 +497,15 @@ static int rockchip_i2s_tdm_set_fmt(struct snd_soc_dai *cpu_dai,
 			val = I2S_TXCR_TFS_TDM_I2S;
 			tdm_val = TDM_SHIFT_CTRL(0);
 			break;
 		case SND_SOC_DAIFMT_DSP_A:
 			val = I2S_TXCR_TFS_TDM_PCM;
-			tdm_val = TDM_SHIFT_CTRL(2);
+			tdm_val = TDM_SHIFT_CTRL(0);
 			break;
 		case SND_SOC_DAIFMT_DSP_B:
 			val = I2S_TXCR_TFS_TDM_PCM;
-			tdm_val = TDM_SHIFT_CTRL(4);
+			tdm_val = TDM_SHIFT_CTRL(2);
 			break;
 		default:
 			ret = -EINVAL;
 			goto err_pm_put;
 		}
@@ -482,28 +529,32 @@ static int rockchip_i2s_tdm_set_fmt(struct snd_soc_dai *cpu_dai,
 	pm_runtime_put(cpu_dai->dev);
 
 	return ret;
 }
 
+// только из rockchip_i2s_trcm_mode
 static void rockchip_i2s_tdm_xfer_pause(struct snd_pcm_substream *substream,
 					struct rk_i2s_tdm_dev *i2s_tdm)
 {
 	int stream;
+	dev_info(i2s_tdm->dev, "rockchip_i2s_tdm_xfer_pause\n");
 
 	stream = SNDRV_PCM_STREAM_LAST - substream->stream;
 	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
 		rockchip_disable_tde(i2s_tdm->regmap);
 	else
 		rockchip_disable_rde(i2s_tdm->regmap);
 
 	rockchip_snd_xfer_clear(i2s_tdm, I2S_CLR_TXC | I2S_CLR_RXC);
 }
 
+// только из rockchip_i2s_trcm_mode
 static void rockchip_i2s_tdm_xfer_resume(struct snd_pcm_substream *substream,
 					 struct rk_i2s_tdm_dev *i2s_tdm)
 {
 	int stream;
+	dev_info(i2s_tdm->dev, "rockchip_i2s_tdm_xfer_resume\n");
 
 	stream = SNDRV_PCM_STREAM_LAST - substream->stream;
 	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
 		rockchip_enable_tde(i2s_tdm->regmap);
 	else
@@ -514,16 +565,44 @@ static void rockchip_i2s_tdm_xfer_resume(struct snd_pcm_substream *substream,
 			   I2S_XFER_RXS_START,
 			   I2S_XFER_TXS_START |
 			   I2S_XFER_RXS_START);
 }
 
+static int rockchip_i2s_ch_to_io(unsigned int ch, bool substream_capture)
+{
+	if (substream_capture) {
+		switch (ch) {
+		case I2S_CHN_4:
+			return I2S_IO_6CH_OUT_4CH_IN;
+		case I2S_CHN_6:
+			return I2S_IO_4CH_OUT_6CH_IN;
+		case I2S_CHN_8:
+			return I2S_IO_2CH_OUT_8CH_IN;
+		default:
+			return I2S_IO_8CH_OUT_2CH_IN;
+		}
+	} else {
+		switch (ch) {
+		case I2S_CHN_4:
+			return I2S_IO_4CH_OUT_6CH_IN;
+		case I2S_CHN_6:
+			return I2S_IO_6CH_OUT_4CH_IN;
+		case I2S_CHN_8:
+			return I2S_IO_8CH_OUT_2CH_IN;
+		default:
+			return I2S_IO_2CH_OUT_8CH_IN;
+		}
+	}
+}
+
 static int rockchip_i2s_io_multiplex(struct snd_pcm_substream *substream,
 				     struct snd_soc_dai *dai)
 {
 	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
 	int usable_chs = MULTIPLEX_CH_MAX;
 	unsigned int val = 0;
+	dev_info(i2s_tdm->dev, "rockchip_i2s_io_multiplex\n");
 
 	if (!i2s_tdm->io_multiplex)
 		return 0;
 
 	if (IS_ERR_OR_NULL(i2s_tdm->grf)) {
@@ -550,10 +629,11 @@ static int rockchip_i2s_io_multiplex(struct snd_pcm_substream *substream,
 				"Capture channels (%d) > usable channels (%d)\n",
 				to_ch_num(val), usable_chs);
 			return -EINVAL;
 		}
 
+		rockchip_i2s_ch_to_io(val, true);
 	} else {
 		struct snd_pcm_str *capture_str =
 			&substream->pcm->streams[SNDRV_PCM_STREAM_CAPTURE];
 
 		if (capture_str->substream_opened) {
@@ -578,18 +658,20 @@ static int rockchip_i2s_io_multiplex(struct snd_pcm_substream *substream,
 	regmap_write(i2s_tdm->grf, i2s_tdm->soc_data->grf_reg_offset, val);
 
 	return 0;
 }
 
+// когда TX и RX - зависимы
 static int rockchip_i2s_trcm_mode(struct snd_pcm_substream *substream,
 				  struct snd_soc_dai *dai,
 				  unsigned int div_bclk,
 				  unsigned int div_lrck,
 				  unsigned int fmt)
 {
 	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
 	unsigned long flags;
+	dev_info(i2s_tdm->dev, "rockchip_i2s_trcm_mode div_bclk=%u, div_lrck=%u, fmt=%u\n", div_bclk, div_lrck, fmt);
 
 	if (!i2s_tdm->clk_trcm)
 		return 0;
 
 	spin_lock_irqsave(&i2s_tdm->lock, flags);
@@ -621,10 +703,11 @@ static int rockchip_i2s_trcm_mode(struct snd_pcm_substream *substream,
 
 static int rockchip_i2s_tdm_set_sysclk(struct snd_soc_dai *cpu_dai, int stream,
 				       unsigned int freq, int dir)
 {
 	struct rk_i2s_tdm_dev *i2s_tdm = to_info(cpu_dai);
+	dev_info(i2s_tdm->dev, "rockchip_i2s_tdm_set_sysclk freq=%u, dir=%d\n", freq, dir);
 
 	if (i2s_tdm->clk_trcm) {
 		i2s_tdm->mclk_tx_freq = freq;
 		i2s_tdm->mclk_rx_freq = freq;
 	} else {
@@ -646,10 +729,11 @@ static int rockchip_i2s_tdm_hw_params(struct snd_pcm_substream *substream,
 {
 	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
 	unsigned int val = 0;
 	unsigned int mclk_rate, bclk_rate, div_bclk = 4, div_lrck = 64;
 	int err;
+	bool s2mono = i2s_tdm->s2mono;
 
 	if (i2s_tdm->is_master_mode) {
 		struct clk *mclk;
 
 		if (i2s_tdm->clk_trcm == TRCM_TX) {
@@ -664,26 +748,80 @@ static int rockchip_i2s_tdm_hw_params(struct snd_pcm_substream *substream,
 		} else {
 			mclk = i2s_tdm->mclk_rx;
 			mclk_rate = i2s_tdm->mclk_rx_freq;
 		}
 
-		/* set to default rate if set_sysclk was never called */
-		if (!mclk_rate)
-			mclk_rate = DEFAULT_MCLK_FS * params_rate(params);
-		err = clk_set_rate(mclk, mclk_rate);
-		if (err)
-			return err;
+//+++
+//+++
+//		dev_dbg(i2s_tdm->dev, "%s dcount = %u, mclk_rate = %u, params_rate(params) = %u\n", 
+//			__func__, i2s_tdm->dcount++, mclk_rate, params_rate(params));
+		dev_info(i2s_tdm->dev, "%s mclk_rate = %u, params_rate(params) = %u, DSD = %d\n", 
+			__func__, mclk_rate, params_rate(params), params_format(params) == SNDRV_PCM_FORMAT_DSD_U32_LE ? 1 : 0);
+//+++
+		if( params_format(params) == SNDRV_PCM_FORMAT_DSD_U32_LE ) 
+			s2mono = 1;
+		if( i2s_tdm->tdm_mode != true ) {
+			if( params_format(params) == SNDRV_PCM_FORMAT_S16_LE ) {
+				div_lrck = 32; i2s_tdm->frame_width = 32;
+				//s2mono = 0;
+			} else if( s2mono ) {
+				div_lrck = 32; i2s_tdm->frame_width = 32;
+			} else {
+				div_lrck = 64; i2s_tdm->frame_width = 64;
+			} 
+			dev_dbg(i2s_tdm->dev, "%s div_lrck %u frame_width %u\n", 
+				__func__, div_lrck, i2s_tdm->frame_width);
+		}
+//+++
+
+		if( !i2s_tdm->mclk_external ){
+			if( params_rate(params) % 44100 )
+				err = clk_set_rate(mclk, 512 * 48000);
+			else
+				err = clk_set_rate(mclk, 512 * 44100);
+			if (err)
+				return err;
+		}
+
+//+++
+		if( i2s_tdm->mclk_external ){
+			if( i2s_tdm->mclk_ext_mux ) {
+				if( params_rate(params) % 44100 ) {
+					clk_set_parent( i2s_tdm->mclk_ext, i2s_tdm->clk_48);
+					dev_dbg(i2s_tdm->dev, "%s external mclk 48x, rate %u\n", 
+						__func__, params_rate(params));
+				}
+				else {
+					clk_set_parent( i2s_tdm->mclk_ext, i2s_tdm->clk_44);
+					dev_dbg(i2s_tdm->dev, "%s external mclk 44x, rate %u\n", 
+						__func__, params_rate(params));
+				}
+			}
+		}
+//+++
 
 		mclk_rate = clk_get_rate(mclk);
 		bclk_rate = i2s_tdm->frame_width * params_rate(params);
 		if (!bclk_rate)
 			return -EINVAL;
 
 		div_bclk = DIV_ROUND_CLOSEST(mclk_rate, bclk_rate);
 		div_lrck = bclk_rate / params_rate(params);
+		dev_dbg(i2s_tdm->dev, "%s, tdm is master, div_bclk %u, div_lrck %u\n", 
+			__func__, div_bclk, div_lrck);
 	}
 
+//+++
+	if( s2mono && (params_format(params) != SNDRV_PCM_FORMAT_S16_LE) ) {
+		val |= I2S_TXCR_VDW(16);
+		val |= I2S_CHN_4;
+		dev_dbg(i2s_tdm->dev, "%s s2mono\n", 
+			__func__);
+		goto s2mono_l;
+	}
+//+++
+
 	switch (params_format(params)) {
 	case SNDRV_PCM_FORMAT_S8:
 		val |= I2S_TXCR_VDW(8);
 		break;
 	case SNDRV_PCM_FORMAT_S16_LE:
@@ -696,10 +834,13 @@ static int rockchip_i2s_tdm_hw_params(struct snd_pcm_substream *substream,
 		val |= I2S_TXCR_VDW(24);
 		break;
 	case SNDRV_PCM_FORMAT_S32_LE:
 		val |= I2S_TXCR_VDW(32);
 		break;
+	case SNDRV_PCM_FORMAT_DSD_U32_LE:
+		val |= I2S_TXCR_VDW(32);
+		break;
 	default:
 		return -EINVAL;
 	}
 
 	switch (params_channels(params)) {
@@ -717,22 +858,40 @@ static int rockchip_i2s_tdm_hw_params(struct snd_pcm_substream *substream,
 		break;
 	default:
 		return -EINVAL;
 	}
 
+s2mono_l:
+	if(i2s_tdm->dsd_gpio) {
+		if(params_format(params) == SNDRV_PCM_FORMAT_DSD_U32_LE)
+            gpiod_set_value(i2s_tdm->dsd_gpio, i2s_tdm->inverse_dsd ? 0 : 1);
+		else
+            gpiod_set_value(i2s_tdm->dsd_gpio, i2s_tdm->inverse_dsd ? 1 : 0);
+	}
+// ToDo
 	if (i2s_tdm->clk_trcm) {
 		rockchip_i2s_trcm_mode(substream, dai, div_bclk, div_lrck, val);
 	} else if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		if(i2s_tdm->leave_word_clock)
+			regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+					   I2S_XFER_TXS_START,
+					   I2S_XFER_TXS_STOP);
+		
 		regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
 				   I2S_CLKDIV_TXM_MASK,
 				   I2S_CLKDIV_TXM(div_bclk));
 		regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
 				   I2S_CKR_TSD_MASK,
 				   I2S_CKR_TSD(div_lrck));
 		regmap_update_bits(i2s_tdm->regmap, I2S_TXCR,
 				   I2S_TXCR_VDW_MASK | I2S_TXCR_CSR_MASK,
 				   val);
+				   
+	if(i2s_tdm->leave_word_clock)
+		regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+				   I2S_XFER_TXS_START,
+				   I2S_XFER_TXS_START);
 	} else {
 		regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
 				   I2S_CLKDIV_RXM_MASK,
 				   I2S_CLKDIV_RXM(div_bclk));
 		regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
@@ -748,10 +907,11 @@ static int rockchip_i2s_tdm_hw_params(struct snd_pcm_substream *substream,
 
 static int rockchip_i2s_tdm_trigger(struct snd_pcm_substream *substream,
 				    int cmd, struct snd_soc_dai *dai)
 {
 	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
+	dev_info(i2s_tdm->dev, "rockchip_i2s_tdm_trigger cmd=%d\n", cmd);
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
@@ -780,25 +940,37 @@ static int rockchip_i2s_tdm_trigger(struct snd_pcm_substream *substream,
 }
 
 static int rockchip_i2s_tdm_dai_probe(struct snd_soc_dai *dai)
 {
 	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+	dev_info(i2s_tdm->dev, "rockchip_i2s_tdm_dai_probe\n");
+
+//+++
+//		dev_dbg(i2s_tdm->dev, "%s dcount = %u\n", 
+//			__func__, i2s_tdm->dcount++);
+//+++
 
 	if (i2s_tdm->has_capture)
 		snd_soc_dai_dma_data_set_capture(dai,  &i2s_tdm->capture_dma_data);
 	if (i2s_tdm->has_playback)
 		snd_soc_dai_dma_data_set_playback(dai, &i2s_tdm->playback_dma_data);
-
+	
 	return 0;
 }
 
 static int rockchip_dai_tdm_slot(struct snd_soc_dai *dai,
 				 unsigned int tx_mask, unsigned int rx_mask,
 				 int slots, int slot_width)
 {
 	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
 	unsigned int mask, val;
+	dev_info(i2s_tdm->dev, "rockchip_dai_tdm_slot tx_mask=%u, rx_mask=%u, slots=%d, slot_width=%d\n", tx_mask, rx_mask, slots, slot_width);
+
+//+++
+//	dev_dbg(i2s_tdm->dev, "%s dcount = %u\n",
+//		__func__, i2s_tdm->dcount++);
+//+++
 
 	i2s_tdm->tdm_mode = true;
 	i2s_tdm->frame_width = slots * slot_width;
 	mask = TDM_SLOT_BIT_WIDTH_MSK | TDM_FRAME_WIDTH_MSK;
 	val = TDM_SLOT_BIT_WIDTH(slot_width) |
@@ -813,10 +985,16 @@ static int rockchip_dai_tdm_slot(struct snd_soc_dai *dai,
 
 static int rockchip_i2s_tdm_set_bclk_ratio(struct snd_soc_dai *dai,
 					   unsigned int ratio)
 {
 	struct rk_i2s_tdm_dev *i2s_tdm = snd_soc_dai_get_drvdata(dai);
+	dev_info(i2s_tdm->dev, "rockchip_i2s_tdm_set_bclk_ratio %u\n", ratio);
+
+//+++
+//	dev_dbg(i2s_tdm->dev, "%s ratio %u dcount = %u\n",
+//		__func__, ratio, i2s_tdm->dcount++);
+//+++
 
 	if (ratio < 32 || ratio > 512 || ratio % 2 == 1)
 		return -EINVAL;
 
 	i2s_tdm->frame_width = ratio;
@@ -934,10 +1112,11 @@ static int common_soc_init(struct device *dev, u32 addr)
 {
 	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
 	const struct txrx_config *configs = i2s_tdm->soc_data->configs;
 	u32 reg = 0, val = 0, trcm = i2s_tdm->clk_trcm;
 	int i;
+	dev_info(i2s_tdm->dev, "common_soc_init %x\n", addr);
 
 	if (trcm == TRCM_TXRX)
 		return 0;
 
 	if (IS_ERR_OR_NULL(i2s_tdm->grf)) {
@@ -1044,12 +1223,13 @@ static int rockchip_i2s_tdm_init_dai(struct rk_i2s_tdm_dev *i2s_tdm)
 	struct snd_soc_dai_driver *dai;
 	struct property *dma_names;
 	const char *dma_name;
 	u64 formats = (SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_LE |
 		       SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE |
-		       SNDRV_PCM_FMTBIT_S32_LE);
+		       SNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_DSD_U32_LE);
 	struct device_node *node = i2s_tdm->dev->of_node;
+	dev_info(i2s_tdm->dev, "rockchip_i2s_tdm_init_dai\n");
 
 	of_property_for_each_string(node, "dma-names", dma_names, dma_name) {
 		if (!strcmp(dma_name, "tx"))
 			i2s_tdm->has_playback = true;
 		if (!strcmp(dma_name, "rx"))
@@ -1063,19 +1243,19 @@ static int rockchip_i2s_tdm_init_dai(struct rk_i2s_tdm_dev *i2s_tdm)
 
 	if (i2s_tdm->has_playback) {
 		dai->playback.stream_name  = "Playback";
 		dai->playback.channels_min = 2;
 		dai->playback.channels_max = 8;
-		dai->playback.rates = SNDRV_PCM_RATE_8000_192000;
+		dai->playback.rates = SNDRV_PCM_RATE_8000_768000;
 		dai->playback.formats = formats;
 	}
 
 	if (i2s_tdm->has_capture) {
 		dai->capture.stream_name  = "Capture";
 		dai->capture.channels_min = 2;
 		dai->capture.channels_max = 8;
-		dai->capture.rates = SNDRV_PCM_RATE_8000_192000;
+		dai->capture.rates = SNDRV_PCM_RATE_8000_768000;
 		dai->capture.formats = formats;
 	}
 
 	if (i2s_tdm->clk_trcm != TRCM_TXRX)
 		dai->symmetric_rate = 1;
@@ -1089,10 +1269,11 @@ static int rockchip_i2s_tdm_path_check(struct rk_i2s_tdm_dev *i2s_tdm,
 				       int num,
 				       bool is_rx_path)
 {
 	unsigned int *i2s_data;
 	int i, j;
+	dev_info(i2s_tdm->dev, "rockchip_i2s_tdm_path_check\n");
 
 	if (is_rx_path)
 		i2s_data = i2s_tdm->i2s_sdis;
 	else
 		i2s_data = i2s_tdm->i2s_sdos;
@@ -1126,10 +1307,11 @@ static int rockchip_i2s_tdm_path_check(struct rk_i2s_tdm_dev *i2s_tdm,
 
 static void rockchip_i2s_tdm_tx_path_config(struct rk_i2s_tdm_dev *i2s_tdm,
 					    int num)
 {
 	int idx;
+	dev_info(i2s_tdm->dev, "rockchip_i2s_tdm_tx_path_config\n");
 
 	for (idx = 0; idx < num; idx++) {
 		regmap_update_bits(i2s_tdm->regmap, I2S_TXCR,
 				   I2S_TXCR_PATH_MASK(idx),
 				   I2S_TXCR_PATH(idx, i2s_tdm->i2s_sdos[idx]));
@@ -1138,10 +1320,11 @@ static void rockchip_i2s_tdm_tx_path_config(struct rk_i2s_tdm_dev *i2s_tdm,
 
 static void rockchip_i2s_tdm_rx_path_config(struct rk_i2s_tdm_dev *i2s_tdm,
 					    int num)
 {
 	int idx;
+	dev_info(i2s_tdm->dev, "rockchip_i2s_tdm_rx_path_config\n");
 
 	for (idx = 0; idx < num; idx++) {
 		regmap_update_bits(i2s_tdm->regmap, I2S_RXCR,
 				   I2S_RXCR_PATH_MASK(idx),
 				   I2S_RXCR_PATH(idx, i2s_tdm->i2s_sdis[idx]));
@@ -1149,10 +1332,11 @@ static void rockchip_i2s_tdm_rx_path_config(struct rk_i2s_tdm_dev *i2s_tdm,
 }
 
 static void rockchip_i2s_tdm_path_config(struct rk_i2s_tdm_dev *i2s_tdm,
 					 int num, bool is_rx_path)
 {
+	dev_info(i2s_tdm->dev, "rockchip_i2s_tdm_path_config\n");
 	if (is_rx_path)
 		rockchip_i2s_tdm_rx_path_config(i2s_tdm, num);
 	else
 		rockchip_i2s_tdm_tx_path_config(i2s_tdm, num);
 }
@@ -1164,10 +1348,11 @@ static int rockchip_i2s_tdm_path_prepare(struct rk_i2s_tdm_dev *i2s_tdm,
 	char *i2s_tx_path_prop = "rockchip,i2s-tx-route";
 	char *i2s_rx_path_prop = "rockchip,i2s-rx-route";
 	char *i2s_path_prop;
 	unsigned int *i2s_data;
 	int num, ret = 0;
+	dev_info(i2s_tdm->dev, "rockchip_i2s_tdm_path_prepare\n");
 
 	if (is_rx_path) {
 		i2s_path_prop = i2s_rx_path_prop;
 		i2s_data = i2s_tdm->i2s_sdis;
 	} else {
@@ -1212,10 +1397,11 @@ static int rockchip_i2s_tdm_path_prepare(struct rk_i2s_tdm_dev *i2s_tdm,
 }
 
 static int rockchip_i2s_tdm_tx_path_prepare(struct rk_i2s_tdm_dev *i2s_tdm,
 					    struct device_node *np)
 {
+	dev_info(i2s_tdm->dev, "rockchip_i2s_tdm_tx_path_prepare\n");
 	return rockchip_i2s_tdm_path_prepare(i2s_tdm, np, 0);
 }
 
 static int rockchip_i2s_tdm_rx_path_prepare(struct rk_i2s_tdm_dev *i2s_tdm,
 					    struct device_node *np)
@@ -1228,10 +1414,11 @@ static int rockchip_i2s_tdm_probe(struct platform_device *pdev)
 	struct device_node *node = pdev->dev.of_node;
 	struct rk_i2s_tdm_dev *i2s_tdm;
 	struct resource *res;
 	void __iomem *regs;
 	int ret;
+	dev_info(&pdev->dev, "rockchip_i2s_tdm_probe\n");
 
 	i2s_tdm = devm_kzalloc(&pdev->dev, sizeof(*i2s_tdm), GFP_KERNEL);
 	if (!i2s_tdm)
 		return -ENOMEM;
 
@@ -1289,10 +1476,66 @@ static int rockchip_i2s_tdm_probe(struct platform_device *pdev)
 	if (IS_ERR(i2s_tdm->mclk_rx)) {
 		return dev_err_probe(i2s_tdm->dev, PTR_ERR(i2s_tdm->mclk_rx),
 				     "Failed to get clock mclk_rx\n");
 	}
 
+//+++
+	i2s_tdm->s2mono = 0;
+	i2s_tdm->s2mono =
+		of_property_read_bool(node, "my,s2mono");
+
+	i2s_tdm->mclk_external = 0;
+	i2s_tdm->mclk_external =
+		of_property_read_bool(node, "my,mclk_external");
+
+	if (i2s_tdm->mclk_external) {
+		i2s_tdm->mclk_ext = devm_clk_get(&pdev->dev, "mclk_ext");
+		if (IS_ERR(i2s_tdm->mclk_ext)) {
+			return dev_err_probe(i2s_tdm->dev, PTR_ERR(i2s_tdm->mclk_ext),
+					     "Failed to get clock mclk_ext\n");
+		}
+		else {
+			i2s_tdm->mclk_ext_mux = 0;
+			i2s_tdm->clk_44 = devm_clk_get(&pdev->dev, "clk_44");
+			if (!IS_ERR(i2s_tdm->clk_44)) {
+				i2s_tdm->clk_48 = devm_clk_get(&pdev->dev, "clk_48");
+				if (!IS_ERR(i2s_tdm->clk_48)) i2s_tdm->mclk_ext_mux = 1;
+			}
+		}
+		// disconnect mclk pin from PLL
+		if ( of_device_is_compatible( node, "rockchip,rk3308-i2s-tdm") ) {
+			void __iomem *gate13;
+			gate13 = ioremap( (resource_size_t) 0xff500000 + 0x0334, 32);
+			writel( 0x300030, gate13);
+			iounmap( gate13 );
+		}
+		dev_info(i2s_tdm->dev, "External master-clock source is used\n");
+	}
+	else
+		dev_info(i2s_tdm->dev, "Internal master-clock source is used\n");
+	
+    i2s_tdm->dsd_gpio = devm_gpiod_get_optional(&pdev->dev, "my,dsd", GPIOD_OUT_HIGH);
+    if (IS_ERR_OR_NULL(i2s_tdm->dsd_gpio)) {
+        i2s_tdm->dsd_gpio = 0;
+        dev_info(i2s_tdm->dev, "%s: DSD indicator not used\n",
+			__func__);
+    }
+    else {
+        if (of_property_read_bool(node, "my,inversion-dsd"))
+            i2s_tdm->inverse_dsd = true;
+        else
+            i2s_tdm->inverse_dsd = false;
+        gpiod_set_value(i2s_tdm->dsd_gpio, i2s_tdm->inverse_dsd ? 1 : 0);
+        dev_info(i2s_tdm->dev, "%s: DSD indicator used, inverse flag = %d\n",
+			__func__, (int)i2s_tdm->inverse_dsd);
+    }
+//+++
+
+//	i2s_tdm->dcount = 0;
+	i2s_tdm->leave_word_clock = 
+		of_property_read_bool(node, "my,leave-word-clock");
+		
 	i2s_tdm->io_multiplex =
 		of_property_read_bool(node, "rockchip,io-multiplex");
 
 	regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
 	if (IS_ERR(regs)) {
@@ -1370,11 +1613,20 @@ static int rockchip_i2s_tdm_probe(struct platform_device *pdev)
 	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);
 	if (ret) {
 		dev_err(&pdev->dev, "Could not register PCM\n");
 		goto err_suspend;
 	}
-
+	
+	if(i2s_tdm->leave_word_clock) {
+        dev_info(i2s_tdm->dev, "start transfer, i2s_tdm->clk_trcm=%d\n", i2s_tdm->clk_trcm);
+		rockchip_snd_xfer_sync_reset(i2s_tdm);
+		regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+				   I2S_XFER_TXS_START |
+				   I2S_XFER_RXS_START,
+				   I2S_XFER_TXS_START |
+				   I2S_XFER_RXS_START);
+	}
 	return 0;
 
 err_suspend:
 	if (!pm_runtime_status_suspended(&pdev->dev))
 		i2s_tdm_runtime_suspend(&pdev->dev);
@@ -1386,29 +1638,32 @@ static int rockchip_i2s_tdm_probe(struct platform_device *pdev)
 	return ret;
 }
 
 static void rockchip_i2s_tdm_remove(struct platform_device *pdev)
 {
+	dev_info(&pdev->dev, "rockchip_i2s_tdm_remove\n");
 	if (!pm_runtime_status_suspended(&pdev->dev))
 		i2s_tdm_runtime_suspend(&pdev->dev);
 
 	pm_runtime_disable(&pdev->dev);
 }
 
-static int rockchip_i2s_tdm_suspend(struct device *dev)
+static int __maybe_unused rockchip_i2s_tdm_suspend(struct device *dev)
 {
 	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
+	dev_info(i2s_tdm->dev, "rockchip_i2s_tdm_suspend\n");
 
 	regcache_mark_dirty(i2s_tdm->regmap);
 
 	return 0;
 }
 
-static int rockchip_i2s_tdm_resume(struct device *dev)
+static int __maybe_unused rockchip_i2s_tdm_resume(struct device *dev)
 {
 	struct rk_i2s_tdm_dev *i2s_tdm = dev_get_drvdata(dev);
 	int ret;
+	dev_info(i2s_tdm->dev, "rockchip_i2s_tdm_resume\n");
 
 	ret = pm_runtime_resume_and_get(dev);
 	if (ret < 0)
 		return ret;
 	ret = regcache_sync(i2s_tdm->regmap);
@@ -1416,21 +1671,23 @@ static int rockchip_i2s_tdm_resume(struct device *dev)
 
 	return ret;
 }
 
 static const struct dev_pm_ops rockchip_i2s_tdm_pm_ops = {
-	RUNTIME_PM_OPS(i2s_tdm_runtime_suspend, i2s_tdm_runtime_resume, NULL)
-	SYSTEM_SLEEP_PM_OPS(rockchip_i2s_tdm_suspend, rockchip_i2s_tdm_resume)
+	SET_RUNTIME_PM_OPS(i2s_tdm_runtime_suspend, i2s_tdm_runtime_resume,
+			   NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(rockchip_i2s_tdm_suspend,
+				rockchip_i2s_tdm_resume)
 };
 
 static struct platform_driver rockchip_i2s_tdm_driver = {
 	.probe = rockchip_i2s_tdm_probe,
 	.remove = rockchip_i2s_tdm_remove,
 	.driver = {
 		.name = DRV_NAME,
 		.of_match_table = rockchip_i2s_tdm_match,
-		.pm = pm_ptr(&rockchip_i2s_tdm_pm_ops),
+		.pm = &rockchip_i2s_tdm_pm_ops,
 	},
 };
 module_platform_driver(rockchip_i2s_tdm_driver);
 
 MODULE_DESCRIPTION("ROCKCHIP I2S/TDM ASoC Interface");
-- 
Created with Armbian build tools https://github.com/armbian/build

