From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: John Doe <john.doe@somewhere.on.planet>
Date: Thu, 23 Oct 2025 18:29:19 +0600
Subject: Patching kernel rockchip64 files
 sound/soc/rockchip/rockchip_i2s_tdm.c

Signed-off-by: John Doe <john.doe@somewhere.on.planet>
---
 sound/soc/rockchip/rockchip_i2s_tdm.c | 174 +++++++++-
 1 file changed, 165 insertions(+), 9 deletions(-)

diff --git a/sound/soc/rockchip/rockchip_i2s_tdm.c b/sound/soc/rockchip/rockchip_i2s_tdm.c
index 3b46c59edbdd..0018a6f19d3d 100644
--- a/sound/soc/rockchip/rockchip_i2s_tdm.c
+++ b/sound/soc/rockchip/rockchip_i2s_tdm.c
@@ -9,10 +9,12 @@
 #include <linux/clk-provider.h>
 #include <linux/delay.h>
 #include <linux/mfd/syscon.h>
 #include <linux/module.h>
 #include <linux/of.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
 #include <linux/pm_runtime.h>
 #include <linux/regmap.h>
 #include <linux/reset.h>
 #include <linux/spinlock.h>
 #include <sound/dmaengine_pcm.h>
@@ -20,11 +22,10 @@
 
 #include "rockchip_i2s_tdm.h"
 
 #define DRV_NAME "rockchip-i2s-tdm"
 
-#define DEFAULT_MCLK_FS				256
 #define CH_GRP_MAX				4  /* The max channel 8 / 2 */
 #define MULTIPLEX_CH_MAX			10
 
 #define TRCM_TXRX 0
 #define TRCM_TX 1
@@ -57,16 +58,28 @@ struct rk_i2s_tdm_dev {
 	struct snd_dmaengine_dai_dma_data playback_dma_data;
 	struct reset_control *tx_reset;
 	struct reset_control *rx_reset;
 	const struct rk_i2s_soc_data *soc_data;
 	bool is_master_mode;
+//+++
+	bool mclk_external;					// using external master-clock source connected to pin I2SX_8CH_MCLK 
+	bool mclk_ext_mux;					// external master-clock source has to two switchable generators x44 and x48
+	bool s2mono;						// using two separate I2S out for left/right channels (dual mono mode)
+	struct clk *mclk_ext;				// external master-clock source
+	struct clk *clk_44;					// external x44 generator
+	struct clk *clk_48;					// external x48 generator
+    struct gpio_desc *dsd_gpio;			// DSD output indicator
+    bool inverse_dsd;					// direct or inverse signal of DSD
+	//int dcount;
+//+++
 	bool io_multiplex;
 	bool tdm_mode;
 	unsigned int frame_width;
 	unsigned int clk_trcm;
 	unsigned int i2s_sdis[CH_GRP_MAX];
 	unsigned int i2s_sdos[CH_GRP_MAX];
+	bool no_off_lrck;
 	int refcount;
 	spinlock_t lock; /* xfer lock */
 	bool has_playback;
 	bool has_capture;
 	struct snd_soc_dai_driver *dai;
@@ -317,19 +330,23 @@ static void rockchip_snd_txrxctrl(struct snd_pcm_substream *substream,
 }
 
 static void rockchip_snd_txctrl(struct rk_i2s_tdm_dev *i2s_tdm, int on)
 {
 	if (on) {
+		if(i2s_tdm->no_off_lrck)
+			rockchip_snd_xfer_clear(i2s_tdm, I2S_CLR_TXC);
+		
 		rockchip_enable_tde(i2s_tdm->regmap);
 
 		regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
 				   I2S_XFER_TXS_START,
 				   I2S_XFER_TXS_START);
 	} else {
 		rockchip_disable_tde(i2s_tdm->regmap);
 
-		rockchip_snd_xfer_clear(i2s_tdm, I2S_CLR_TXC);
+		if(!i2s_tdm->no_off_lrck)
+			rockchip_snd_xfer_clear(i2s_tdm, I2S_CLR_TXC);
 	}
 }
 
 static void rockchip_snd_rxctrl(struct rk_i2s_tdm_dev *i2s_tdm, int on)
 {
@@ -646,10 +663,11 @@ static int rockchip_i2s_tdm_hw_params(struct snd_pcm_substream *substream,
 {
 	struct rk_i2s_tdm_dev *i2s_tdm = to_info(dai);
 	unsigned int val = 0;
 	unsigned int mclk_rate, bclk_rate, div_bclk = 4, div_lrck = 64;
 	int err;
+	bool s2mono = i2s_tdm->s2mono;
 
 	if (i2s_tdm->is_master_mode) {
 		struct clk *mclk;
 
 		if (i2s_tdm->clk_trcm == TRCM_TX) {
@@ -664,26 +682,78 @@ static int rockchip_i2s_tdm_hw_params(struct snd_pcm_substream *substream,
 		} else {
 			mclk = i2s_tdm->mclk_rx;
 			mclk_rate = i2s_tdm->mclk_rx_freq;
 		}
 
-		/* set to default rate if set_sysclk was never called */
-		if (!mclk_rate)
-			mclk_rate = DEFAULT_MCLK_FS * params_rate(params);
-		err = clk_set_rate(mclk, mclk_rate);
+//+++
+//+++
+//		dev_info(i2s_tdm->dev, "%s mclk_rate = %u, params_rate(params) = %u, DSD = %d\n", 
+//			__func__, mclk_rate, params_rate(params), params_format(params) == SNDRV_PCM_FORMAT_DSD_U32_LE ? 1 : 0);
+//+++
+		if( params_format(params) == SNDRV_PCM_FORMAT_DSD_U32_LE ) 
+			s2mono = 1;
+		if( i2s_tdm->tdm_mode != true ) {
+			if( params_format(params) == SNDRV_PCM_FORMAT_S16_LE ) {
+				div_lrck = 32; i2s_tdm->frame_width = 32;
+				//s2mono = 0;
+			} else if( s2mono ) {
+				div_lrck = 32; i2s_tdm->frame_width = 32;
+			} else {
+				div_lrck = 64; i2s_tdm->frame_width = 64;
+			} 
+			dev_dbg(i2s_tdm->dev, "%s div_lrck %u frame_width %u\n", 
+				__func__, div_lrck, i2s_tdm->frame_width);
+		}
+//+++
+
+		if( !i2s_tdm->mclk_external ){
+			if( params_rate(params) % 44100 )
+				err = clk_set_rate(mclk, 512 * 48000);
+			else
+				err = clk_set_rate(mclk, 512 * 44100);
 		if (err)
 			return err;
+		}
+
+//+++
+		if( i2s_tdm->mclk_external ){
+			if( i2s_tdm->mclk_ext_mux ) {
+				if( params_rate(params) % 44100 ) {
+					clk_set_parent( i2s_tdm->mclk_ext, i2s_tdm->clk_48);
+					dev_dbg(i2s_tdm->dev, "%s external mclk 48x, rate %u\n", 
+						__func__, params_rate(params));
+				}
+				else {
+					clk_set_parent( i2s_tdm->mclk_ext, i2s_tdm->clk_44);
+					dev_dbg(i2s_tdm->dev, "%s external mclk 44x, rate %u\n", 
+						__func__, params_rate(params));
+				}
+			}
+		}
+//+++
 
 		mclk_rate = clk_get_rate(mclk);
 		bclk_rate = i2s_tdm->frame_width * params_rate(params);
 		if (!bclk_rate)
 			return -EINVAL;
 
 		div_bclk = DIV_ROUND_CLOSEST(mclk_rate, bclk_rate);
 		div_lrck = bclk_rate / params_rate(params);
+		dev_dbg(i2s_tdm->dev, "%s, tdm is master, div_bclk %u, div_lrck %u\n", 
+			__func__, div_bclk, div_lrck);
 	}
 
+//+++
+	if( s2mono && (params_format(params) != SNDRV_PCM_FORMAT_S16_LE) ) {
+		val |= I2S_TXCR_VDW(16);
+		val |= I2S_CHN_4;
+		dev_dbg(i2s_tdm->dev, "%s s2mono\n", 
+			__func__);
+		goto s2mono_l;
+	}
+//+++
+
 	switch (params_format(params)) {
 	case SNDRV_PCM_FORMAT_S8:
 		val |= I2S_TXCR_VDW(8);
 		break;
 	case SNDRV_PCM_FORMAT_S16_LE:
@@ -696,10 +766,13 @@ static int rockchip_i2s_tdm_hw_params(struct snd_pcm_substream *substream,
 		val |= I2S_TXCR_VDW(24);
 		break;
 	case SNDRV_PCM_FORMAT_S32_LE:
 		val |= I2S_TXCR_VDW(32);
 		break;
+	case SNDRV_PCM_FORMAT_DSD_U32_LE:
+		val |= I2S_TXCR_VDW(32);
+		break;
 	default:
 		return -EINVAL;
 	}
 
 	switch (params_channels(params)) {
@@ -717,22 +790,40 @@ static int rockchip_i2s_tdm_hw_params(struct snd_pcm_substream *substream,
 		break;
 	default:
 		return -EINVAL;
 	}
 
+s2mono_l:
+	if(i2s_tdm->dsd_gpio) {
+		if(params_format(params) == SNDRV_PCM_FORMAT_DSD_U32_LE)
+            gpiod_set_value(i2s_tdm->dsd_gpio, i2s_tdm->inverse_dsd ? 0 : 1);
+		else
+            gpiod_set_value(i2s_tdm->dsd_gpio, i2s_tdm->inverse_dsd ? 1 : 0);
+	}
+// ToDo
 	if (i2s_tdm->clk_trcm) {
 		rockchip_i2s_trcm_mode(substream, dai, div_bclk, div_lrck, val);
 	} else if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		if(i2s_tdm->no_off_lrck)
+			regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+					   I2S_XFER_TXS_START,
+					   I2S_XFER_TXS_STOP);
+		
 		regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
 				   I2S_CLKDIV_TXM_MASK,
 				   I2S_CLKDIV_TXM(div_bclk));
 		regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
 				   I2S_CKR_TSD_MASK,
 				   I2S_CKR_TSD(div_lrck));
 		regmap_update_bits(i2s_tdm->regmap, I2S_TXCR,
 				   I2S_TXCR_VDW_MASK | I2S_TXCR_CSR_MASK,
 				   val);
+				   
+	if(i2s_tdm->no_off_lrck)
+		regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+				   I2S_XFER_TXS_START,
+				   I2S_XFER_TXS_START);
 	} else {
 		regmap_update_bits(i2s_tdm->regmap, I2S_CLKDIV,
 				   I2S_CLKDIV_RXM_MASK,
 				   I2S_CLKDIV_RXM(div_bclk));
 		regmap_update_bits(i2s_tdm->regmap, I2S_CKR,
@@ -1044,11 +1135,11 @@ static int rockchip_i2s_tdm_init_dai(struct rk_i2s_tdm_dev *i2s_tdm)
 	struct snd_soc_dai_driver *dai;
 	struct property *dma_names;
 	const char *dma_name;
 	u64 formats = (SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_LE |
 		       SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE |
-		       SNDRV_PCM_FMTBIT_S32_LE);
+		       SNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_DSD_U32_LE);
 	struct device_node *node = i2s_tdm->dev->of_node;
 
 	of_property_for_each_string(node, "dma-names", dma_names, dma_name) {
 		if (!strcmp(dma_name, "tx"))
 			i2s_tdm->has_playback = true;
@@ -1063,19 +1154,19 @@ static int rockchip_i2s_tdm_init_dai(struct rk_i2s_tdm_dev *i2s_tdm)
 
 	if (i2s_tdm->has_playback) {
 		dai->playback.stream_name  = "Playback";
 		dai->playback.channels_min = 2;
 		dai->playback.channels_max = 8;
-		dai->playback.rates = SNDRV_PCM_RATE_8000_192000;
+		dai->playback.rates = SNDRV_PCM_RATE_8000_768000;
 		dai->playback.formats = formats;
 	}
 
 	if (i2s_tdm->has_capture) {
 		dai->capture.stream_name  = "Capture";
 		dai->capture.channels_min = 2;
 		dai->capture.channels_max = 8;
-		dai->capture.rates = SNDRV_PCM_RATE_8000_192000;
+		dai->capture.rates = SNDRV_PCM_RATE_8000_768000;
 		dai->capture.formats = formats;
 	}
 
 	if (i2s_tdm->clk_trcm != TRCM_TXRX)
 		dai->symmetric_rate = 1;
@@ -1289,10 +1380,66 @@ static int rockchip_i2s_tdm_probe(struct platform_device *pdev)
 	if (IS_ERR(i2s_tdm->mclk_rx)) {
 		return dev_err_probe(i2s_tdm->dev, PTR_ERR(i2s_tdm->mclk_rx),
 				     "Failed to get clock mclk_rx\n");
 	}
 
+//+++
+	i2s_tdm->s2mono = 0;
+	i2s_tdm->s2mono =
+		of_property_read_bool(node, "my,s2mono");
+
+	i2s_tdm->mclk_external = 0;
+	i2s_tdm->mclk_external =
+		of_property_read_bool(node, "my,mclk_external");
+
+	if (i2s_tdm->mclk_external) {
+		i2s_tdm->mclk_ext = devm_clk_get(&pdev->dev, "mclk_ext");
+		if (IS_ERR(i2s_tdm->mclk_ext)) {
+			return dev_err_probe(i2s_tdm->dev, PTR_ERR(i2s_tdm->mclk_ext),
+					     "Failed to get clock mclk_ext\n");
+		}
+		else {
+			i2s_tdm->mclk_ext_mux = 0;
+			i2s_tdm->clk_44 = devm_clk_get(&pdev->dev, "clk_44");
+			if (!IS_ERR(i2s_tdm->clk_44)) {
+				i2s_tdm->clk_48 = devm_clk_get(&pdev->dev, "clk_48");
+				if (!IS_ERR(i2s_tdm->clk_48)) i2s_tdm->mclk_ext_mux = 1;
+			}
+		}
+		// disconnect mclk pin from PLL
+		if ( of_device_is_compatible( node, "rockchip,rk3308-i2s-tdm") ) {
+			void __iomem *gate13;
+			gate13 = ioremap( (resource_size_t) 0xff500000 + 0x0334, 32);
+			writel( 0x300030, gate13);
+			iounmap( gate13 );
+		}
+		dev_info(i2s_tdm->dev, "External master-clock source is used\n");
+	}
+	else
+		dev_info(i2s_tdm->dev, "Internal master-clock source is used\n");
+	
+    i2s_tdm->dsd_gpio = devm_gpiod_get_optional(&pdev->dev, "my,dsd", GPIOD_OUT_HIGH);
+    if (IS_ERR_OR_NULL(i2s_tdm->dsd_gpio)) {
+        i2s_tdm->dsd_gpio = 0;
+        dev_info(i2s_tdm->dev, "%s: DSD indicator not used\n",
+			__func__);
+    }
+    else {
+        if (of_property_read_bool(node, "my,inversion-dsd"))
+            i2s_tdm->inverse_dsd = true;
+        else
+            i2s_tdm->inverse_dsd = false;
+        gpiod_set_value(i2s_tdm->dsd_gpio, i2s_tdm->inverse_dsd ? 1 : 0);
+        dev_info(i2s_tdm->dev, "%s: DSD indicator used, inverse flag = %d\n",
+			__func__, (int)i2s_tdm->inverse_dsd);
+    }
+//+++
+
+//	i2s_tdm->dcount = 0;
+	i2s_tdm->no_off_lrck = 
+		of_property_read_bool(node, "my,no-off-lrck");
+		
 	i2s_tdm->io_multiplex =
 		of_property_read_bool(node, "rockchip,io-multiplex");
 
 	regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
 	if (IS_ERR(regs)) {
@@ -1371,10 +1518,19 @@ static int rockchip_i2s_tdm_probe(struct platform_device *pdev)
 	if (ret) {
 		dev_err(&pdev->dev, "Could not register PCM\n");
 		goto err_suspend;
 	}
 
+	if(i2s_tdm->no_off_lrck) {
+        dev_info(i2s_tdm->dev, "start transfer, i2s_tdm->clk_trcm=%d\n", i2s_tdm->clk_trcm);
+		rockchip_snd_xfer_sync_reset(i2s_tdm);
+		regmap_update_bits(i2s_tdm->regmap, I2S_XFER,
+				   I2S_XFER_TXS_START |
+				   I2S_XFER_RXS_START,
+				   I2S_XFER_TXS_START |
+				   I2S_XFER_RXS_START);
+	}
 	return 0;
 
 err_suspend:
 	if (!pm_runtime_status_suspended(&pdev->dev))
 		i2s_tdm_runtime_suspend(&pdev->dev);
-- 
Created with Armbian build tools https://github.com/armbian/build

