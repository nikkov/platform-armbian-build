From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: John Doe <john.doe@somewhere.on.planet>
Date: Sun, 7 Sep 2025 12:30:44 +0600
Subject: Patching kernel rockchip64 files sound/soc/codecs/Kconfig
 sound/soc/codecs/Makefile sound/soc/codecs/i2s_codec.c

Signed-off-by: John Doe <john.doe@somewhere.on.planet>
---
 sound/soc/codecs/Kconfig     |   3 +
 sound/soc/codecs/Makefile    |   2 +
 sound/soc/codecs/i2s_codec.c | 227 ++++++++++
 3 files changed, 232 insertions(+)

diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 126f897312d4..890cfdf03df9 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -1507,10 +1507,13 @@ config SND_SOC_PCM3168A_SPI
 	select REGMAP_SPI
 
 config SND_SOC_PCM5102A
 	tristate "Texas Instruments PCM5102A CODEC"
 
+config SND_SOC_I2S_CODEC
+	tristate "Simple I2S codec"
+
 config SND_SOC_PCM512x
 	tristate
 
 config SND_SOC_PCM512x_I2C
 	tristate "Texas Instruments PCM512x CODECs - I2C"
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index 6d7aa109ede7..9b033babbfe8 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -215,10 +215,11 @@ snd-soc-pcm3060-i2c-y := pcm3060-i2c.o
 snd-soc-pcm3060-spi-y := pcm3060-spi.o
 snd-soc-pcm3168a-y := pcm3168a.o
 snd-soc-pcm3168a-i2c-y := pcm3168a-i2c.o
 snd-soc-pcm3168a-spi-y := pcm3168a-spi.o
 snd-soc-pcm5102a-y := pcm5102a.o
+snd-soc-i2s_codec-objs := i2s_codec.o
 snd-soc-pcm512x-y := pcm512x.o
 snd-soc-pcm512x-i2c-y := pcm512x-i2c.o
 snd-soc-pcm512x-spi-y := pcm512x-spi.o
 snd-soc-pcm6240-y := pcm6240.o
 snd-soc-peb2466-y := peb2466.o
@@ -634,10 +635,11 @@ obj-$(CONFIG_SND_SOC_PCM3060_I2C)	+= snd-soc-pcm3060-i2c.o
 obj-$(CONFIG_SND_SOC_PCM3060_SPI)	+= snd-soc-pcm3060-spi.o
 obj-$(CONFIG_SND_SOC_PCM3168A)	+= snd-soc-pcm3168a.o
 obj-$(CONFIG_SND_SOC_PCM3168A_I2C)	+= snd-soc-pcm3168a-i2c.o
 obj-$(CONFIG_SND_SOC_PCM3168A_SPI)	+= snd-soc-pcm3168a-spi.o
 obj-$(CONFIG_SND_SOC_PCM5102A)	+= snd-soc-pcm5102a.o
+obj-$(CONFIG_SND_SOC_I2S_CODEC)	+= snd-soc-i2s_codec.o
 obj-$(CONFIG_SND_SOC_PCM512x)	+= snd-soc-pcm512x.o
 obj-$(CONFIG_SND_SOC_PCM512x_I2C)	+= snd-soc-pcm512x-i2c.o
 obj-$(CONFIG_SND_SOC_PCM512x_SPI)	+= snd-soc-pcm512x-spi.o
 obj-$(CONFIG_SND_SOC_PCM6240)	+= snd-soc-pcm6240.o
 obj-$(CONFIG_SND_SOC_PEB2466)	+= snd-soc-peb2466.o
diff --git a/sound/soc/codecs/i2s_codec.c b/sound/soc/codecs/i2s_codec.c
new file mode 100644
index 000000000000..658b08abba8c
--- /dev/null
+++ b/sound/soc/codecs/i2s_codec.c
@@ -0,0 +1,227 @@
+/*
+ * Driver for clocks board for i2s bus
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+#include <linux/clk.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/platform_device.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-component.h>
+
+struct i2s_clock_board_priv {
+    struct device *dev;
+    // mute pin, =0 if not used
+    struct gpio_desc *pd_gpio;
+	// 2 pins to indicate the value of the divisor
+	struct gpio_descs *div_gpios;
+	u8 div_array[4];
+    bool inverse_mute;
+};
+
+
+static const struct snd_soc_component_driver soc_codec_i2s_clock_board = {
+};
+
+static int set_clock(struct i2s_clock_board_priv *priv, unsigned long rate)
+{
+	u8 pins_value = 0;
+	if(priv->div_gpios == NULL)
+		return 0;
+
+	switch(rate)
+	{
+		case 44100:
+		case 48000:
+			pins_value = priv->div_array[0];
+			break;
+		case 88200:
+		case 96000:
+			pins_value = priv->div_array[1];
+			break;
+		case 176400:
+		case 192000:
+			pins_value = priv->div_array[2];
+			break;
+		case 384000:
+        case 352800:
+			pins_value = priv->div_array[3];
+			break;
+		default:
+			return ENOENT;
+	}
+
+	gpiod_set_value(priv->div_gpios->desc[0], pins_value & 1);
+	gpiod_set_value(priv->div_gpios->desc[1], (pins_value & 2) >> 1);
+	
+	return 0;
+}
+
+static int i2s_clock_board_trigger(struct snd_pcm_substream *substream, int cmd,
+             struct snd_soc_dai *dai)
+{
+    struct snd_soc_component *component = dai->component;
+    struct i2s_clock_board_priv *priv = snd_soc_component_get_drvdata(component);
+    switch (cmd) {
+        case SNDRV_PCM_TRIGGER_START:
+        case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+        case SNDRV_PCM_TRIGGER_RESUME:
+            dev_dbg(priv->dev, "i2s_clock_board: %s, component %s start\n", __func__, component->name);
+            if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+                if (priv->pd_gpio)
+                    gpiod_set_value(priv->pd_gpio, priv->inverse_mute ? 1 : 0);
+            }
+            else {
+            }
+        break;
+
+        case SNDRV_PCM_TRIGGER_STOP:
+        case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+        case SNDRV_PCM_TRIGGER_SUSPEND:
+            dev_dbg(priv->dev, "i2s_clock_board: %s, component %s stop\n", __func__, component->name);
+            if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+                if (priv->pd_gpio)
+                    gpiod_set_value(priv->pd_gpio, priv->inverse_mute ? 0 : 1);
+            }
+            else {
+            }
+        break;
+
+        default:
+        return -EINVAL;
+    }
+
+    return 0;
+}
+
+static int i2s_clock_board_hw_params(struct snd_pcm_substream *substream,
+			    struct snd_pcm_hw_params *params,
+			    struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *component = dai->component;
+	struct i2s_clock_board_priv *priv = snd_soc_component_get_drvdata(component);
+	unsigned long rate = params_rate(params);
+	dev_dbg(priv->dev, "i2s_clock_board: %s, physical_width=%d, rate=%d, width=%d, format=%d\n", __func__, 
+		(int)params_physical_width(params),
+		(int)params_rate(params),
+		(int)params_width(params),
+		(int)params_format(params)
+	);
+	if(params_format(params) == SNDRV_PCM_FORMAT_DSD_U32_LE)
+		rate /= 2;
+	return set_clock(priv, rate);
+}
+
+static const struct snd_soc_dai_ops i2s_clock_board_dai_ops = {
+    .trigger    = i2s_clock_board_trigger,
+	.hw_params	= i2s_clock_board_hw_params,
+};
+
+static struct snd_soc_dai_driver i2s_clock_board_dai = {
+    .name               = "i2s_clock_board",
+    .playback = {
+        .stream_name    = "Playback",
+        .channels_min   = 2,
+        .channels_max   = 8,
+        .rates          = SNDRV_PCM_RATE_KNOT,
+        .formats        = (SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE |
+		       SNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_DSD_U32_LE),
+    },
+    .capture = {
+        .stream_name    = "Capture",
+        .channels_min   = 2,
+        .channels_max   = 8,
+        .rates          = SNDRV_PCM_RATE_KNOT,
+        .formats        = (SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE |
+		       SNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_DSD_U32_LE),
+    },
+    .ops                = &i2s_clock_board_dai_ops,
+};
+
+static const struct of_device_id i2s_clock_board_dt_ids[] = {
+    { .compatible = "custom,i2s_clock_board", },
+    { }
+};
+MODULE_DEVICE_TABLE(of, i2s_clock_board_dt_ids);
+
+static int i2s_clock_board_probe(struct platform_device *pdev)
+{
+    struct device *dev = &pdev->dev;
+    struct i2s_clock_board_priv *priv;
+	int rprop_res;
+
+    dev_dbg(dev, "%s\n", __func__);
+    priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+    if (!priv)
+        return -ENOMEM;
+
+    dev_set_drvdata(dev, priv);
+    priv->dev = &pdev->dev;
+	
+    priv->pd_gpio = devm_gpiod_get(dev, "mute", GPIOD_OUT_HIGH);
+    if (IS_ERR(priv->pd_gpio)) {
+        priv->pd_gpio = 0;
+        dev_info(dev, "%s: mute not used\n", __func__);
+    }
+    else {
+        if (of_property_read_bool(dev->of_node, "inversion-mute"))
+            priv->inverse_mute = true;
+        else
+            priv->inverse_mute = false;
+        gpiod_set_value(priv->pd_gpio, priv->inverse_mute ? 0 : 1);
+        dev_info(dev, "%s: mute used, inverse flag = %d\n", __func__, (int)priv->inverse_mute);
+    }
+	
+	priv->div_gpios = devm_gpiod_get_array(dev, "div", GPIOD_OUT_HIGH);
+	if (IS_ERR(priv->div_gpios)) {
+        dev_info(dev, "%s: Failed to get GPIO array: %ld, dividers gpio not used\n", __func__, PTR_ERR(priv->div_gpios));
+		priv->div_gpios = NULL;
+	}
+	else {
+		if(priv->div_gpios->ndescs != 2) {
+			dev_err(dev, "gpio dividers pin number wrong count %u\n", priv->div_gpios->ndescs);
+			return -EINVAL;
+		}
+		rprop_res = of_property_read_variable_u8_array(dev->of_node, "div-values", priv->div_array, 1, 4);
+		if (rprop_res < 0) {
+			dev_err(dev, "Failed to read div-values property: %d\n", rprop_res);
+			return rprop_res;
+		}
+		if (rprop_res != 4) {
+			dev_err(dev, "Failed to read div-values property: wrong count %d\n", rprop_res);
+			return rprop_res;
+		}
+		for (size_t i = 0; i < 4; i++)
+			dev_info(dev, "div_array[%zu] = 0x%02x\n", i, priv->div_array[i]);
+	}
+
+    return snd_soc_register_component(dev, &soc_codec_i2s_clock_board,
+		&i2s_clock_board_dai, 1);
+}
+
+static struct platform_driver i2s_clock_board_driver = {
+    .probe              = i2s_clock_board_probe,
+    .driver             = {
+        .name           = "i2s_clock_board",
+        .of_match_table = of_match_ptr(i2s_clock_board_dt_ids),
+    },
+};
+
+module_platform_driver(i2s_clock_board_driver);
+
+MODULE_DESCRIPTION("ASoC external clock board for I2S bus");
+MODULE_LICENSE("GPL v2");
\ No newline at end of file
-- 
Created with Armbian build tools https://github.com/armbian/build

